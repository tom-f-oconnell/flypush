#!/usr/bin/env python3

"""
A web application for maintaining data about fruit fly stocks, to be linked with
experimental data for use in analysis.
"""

import os
import socket

from flask import Flask
from flask import render_template, abort, request
from sqlalchemy import create_engine
import pandas as pd
# TODO clean up these imports...
from wtforms import Form, StringField, SelectField, BooleanField, DateTimeField
from wtforms import IntegerField, DateField, DecimalField, FileField
from wtforms import TextAreaField, RadioField, SubmitField, validators

session_key_file = 'FLASK_SESSION_SECRET'
def generate_session_key():
    with open(session_key_file, 'wb') as f:
        f.write(os.urandom(16))

app = Flask(__name__)

if not os.path.exists(session_key_file):
    generate_session_key()

with open(session_key_file, 'rb') as f:
    app.secret_key = f.read()

url = 'postgresql+psycopg2://flypush:flypush@localhost:5432/flypush'
conn = create_engine(url)

class Table:
    def __init__(self, name):
        self.name = name
        self.url = name
        self.checked_for_history = False
        self.join_with = None
        self.join_on = None

    def column_field(self, column_info):
        """Takes list of Postgres attributes to appropriate wtform Field.

        Can also return None if no field should be generated for this column.
        """
        # TODO TODO should probably be two separate fields: one for updating
        # static table items, and one for adding new ones?
        # TODO switch to using dict for column_info to prevent alignment issues
        col_name, type_str, element_type, udt_name, nullable = column_info

        # Placement of this if here assumes foreign key won't be an array, but
        # that's probably going to be true.
        if type_str == 'ARRAY':
            if element_type == 'ARRAY':
                raise ValueError('nested arrays not supported.')
            type_str = element_type
            # TODO maybe use query for types that uses element_types for arrays,
            # and adds some kind of 'multiple' flag (or uses nested Field?) in
            # Array case?

        # TODO TODO this query should also probably be changed to detect FKs
        # from history table referencing static table, and also use combobox
        # there
        fk_q = '''
        SELECT
            ccu.table_schema,
            ccu.table_name,
            ccu.column_name
        FROM 
            information_schema.table_constraints AS tc 
            JOIN information_schema.key_column_usage AS kcu
              ON tc.constraint_name = kcu.constraint_name
              AND tc.table_schema = kcu.table_schema
            JOIN information_schema.constraint_column_usage AS ccu
              ON ccu.constraint_name = tc.constraint_name
              AND ccu.table_schema = tc.table_schema
        WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='{}'
            AND kcu.column_name='{}'
        '''.format(self.name, col_name)
        rows = conn.execute(fk_q)
        if rows.rowcount > 0:
            r = list(rows)[0]
            foreign_table_schema, foreign_table_name, foreign_col_name = r
            fk_values_q = 'SELECT {} FROM {}'.format(
                foreign_col_name, foreign_table_name)
            keys = conn.execute(fk_values_q)

            field_cls = lambda *args: \
                RadioField(*args, choices=[(k[0], k[0]) for k in keys])

            # TODO dropdown w/ string repr of elements of fk in foreign table

        # TODO don't display fields that are supposed to be generated by the
        # database (like SERIAL id types)
        # TODO also autogenerate (and don't display) updated entries
        elif type_str == 'integer' or type_str == 'smallint':
            # So we don't generate fields for autogenerated serial columns.
            # from SO answer to question 90555 by Erwin Brandstetter
            serial_check_q = """
            SELECT a.attrelid::regclass::text, a.attname
                 , CASE a.atttypid
                     WHEN 'int'::regtype  THEN 'serial'
                     WHEN 'int8'::regtype THEN 'bigserial'
                     WHEN 'int2'::regtype THEN 'smallserial'
                   END AS serial_type
            FROM   pg_attribute  a
            JOIN   pg_constraint c ON c.conrelid  = a.attrelid
                                  AND c.conkey[1] = a.attnum 
            JOIN   pg_attrdef   ad ON ad.adrelid  = a.attrelid
                                  AND ad.adnum    = a.attnum
            WHERE  a.attrelid = 'fly_lines'::regclass
            AND    a.attnum > 0
            AND    NOT a.attisdropped
            AND    a.atttypid = ANY('{{int,int8,int2}}'::regtype[])
            AND    c.contype = 'p'                 -- PK
            AND    array_length(c.conkey, 1) = 1   -- single column
            AND    ad.adsrc = 'nextval('''
                || (pg_get_serial_sequence
                    (a.attrelid::regclass::text, a.attname))::regclass
                || '''::regclass)';     -- col default = nextval from owned seq
	    """.format(self.name)
            rows = conn.execute(serial_check_q)
            if rows.rowcount > 0:
                r = list(rows)[0]
                serial_col_name = str(r[1])
                if serial_col_name == col_name:
                    return None
            field_cls = IntegerField

        elif type_str == 'real':
            field_cls = DecimalField

        elif type_str == 'boolean':
            field_cls = BooleanField

        elif type_str == 'text':
            if 'notes' in col_name or 'protocol' in col_name:
                field_cls = TextAreaField
            else:
                field_cls = StringField

        # TODO maybe normalize to internal type?
        elif type_str == 'timestamp with time zone':
            # TODO use datetime ext
            # TODO default to current date / time
            field_cls = DateTimeField

            # TODO if col_name is 'updated' autofill date
            # (will need to handle an empty return from this fn, probably)

        elif type_str == 'date':
            # TODO tz indicated somewhere in postgres? should it have been?
            field_cls = DateField

        elif type_str == 'bytea':
            # TODO TODO need to also add preferred type / capture attributes
            if element_type is None:
                field_cls = FileField
            else:
                field_cls = \
                    lambda *args: FileField(*args, render_kw={'multiple': True})

        elif type_str == 'USER-DEFINED':
            # could add namespace later if it ends up mattering
            enum_q = 'SELECT unnest(enum_range(NULL::{}))'.format(udt_name)
            values = [(x[0], pretty_name(x[0])) for x in conn.execute(enum_q)]
            field_cls = \
                lambda *args: RadioField(*args, choices=values)

        else:
            raise ValueError('unexpected type ' + type_str)

        checks = []
        if nullable == 'NO':
            checks.append(validators.DataRequired())

        # TODO unique constraint?

        return field_cls(pretty_name(col_name) +
            ('?' if type_str == 'boolean' else ''), checks)


    def check_for_history(self):
        if self.checked_for_history:
            return

        ref_q = '''
        SELECT
            tc.table_name as history_table,
            ccu.table_name as static_table,
            kcu.column_name

        FROM
          information_schema.table_constraints tc
          JOIN information_schema.constraint_column_usage AS ccu
            USING (constraint_schema, constraint_name)
          JOIN information_schema.columns AS c
            ON c.table_schema = tc.constraint_schema
            AND tc.table_name = c.table_name AND ccu.column_name = c.column_name
          JOIN information_schema.key_column_usage AS kcu
            ON tc.constraint_name = kcu.constraint_name
            AND tc.table_schema = kcu.table_schema

        WHERE ccu.table_name = '{}'
          AND kcu.column_name = ccu.column_name
          AND constraint_type = 'FOREIGN KEY' AND is_nullable = 'NO'
        '''.format(self.name)
        # TODO just get out history_table field for input to second sql
        # statement (?)
        rows = list(conn.execute(ref_q))
        candidates = [r[0] for r in rows]

        if len(candidates) == 0:
            return

        pk_q = '''
        SELECT COUNT(*)
        FROM
          information_schema.table_constraints tc
          JOIN information_schema.constraint_column_usage AS ccu
          USING (constraint_schema, constraint_name)
          JOIN information_schema.columns AS c
          ON c.table_schema = tc.constraint_schema
          AND tc.table_name = c.table_name AND ccu.column_name = c.column_name
        WHERE data_type = 'timestamp with time zone'
          AND constraint_type = 'PRIMARY KEY'
          AND tc.table_name {};
        '''.format('in {}'.format(tuple(candidates)) if len(candidates) > 1 else
            "= '{}'".format(candidates[0]))

        # will this fail in some cases? more idiomatic way to get count?
        count = list(conn.execute(pk_q))[0][0]
        if count == 0:
            return

        assert len(rows) == 1
        static_table = rows[0][1]
        history_table = rows[0][0]
        common_id_col = rows[0][2]

        self.join_with = history_table
        self.join_on = common_id_col


    def to_df(self):
        """Returns DataFrame for data in SQL table table_name.

        For case where table is table describing static objects, with associated
        history table, the two tables are joined.
        """
        self.check_for_history()

        if self.join_with is None:
            return pd.read_sql_table(self.name, con=conn)
        else:
            # TODO make sure this join is what I want, once I get actual data
            join_q = 'SELECT * FROM {} JOIN {} USING ({})'.format(
                self.name, self.join_with, self.join_on)
            return pd.read_sql_query(join_q, con=conn)


    # TODO order fields in same way as table, for rendering
    # TODO TODO row only missing elements when updating rows (?)
    # (e.g. when clearing bottles)
    # TODO TODO or could show only next fields expected to be entry, determined
    # from some kind of state machine)
    def add_row_form(self, request_form):
        class RowForm(Form):
            pass

        # TODO <input type="file" accept"image/*" multiple/> ?
        # TODO map postgres check constraints to data validation

        # TODO TODO dropdown on existing foreign keys OR field to add new one
        # put add option in dropdown? display differently in case where db is
        # empty? ("combobox"?)
        self.check_for_history()

        header_q = """
            SELECT
              c.column_name,
              c.data_type,
              e.data_type AS element_type,
              c.udt_name,
              c.is_nullable,
              c.ordinal_position
            FROM information_schema.columns c
              LEFT JOIN information_schema.element_types e ON
              ((c.table_catalog, c.table_schema, c.table_name,
                'TABLE', c.dtd_identifier) =
               
               (e.object_catalog, e.object_schema, e.object_name,
                e.object_type, e.collection_type_identifier))

            WHERE c.table_name {}""".format("= '{}'".format(self.name)
            if self.join_with is None else "in ('{}','{}')".format(
                self.name, self.join_with))

        rows = conn.execute(header_q)
        seen_rows = set()
        order_and_label = []
        for i, row in enumerate(rows):
            r = tuple(row[:-1])
            if r in seen_rows:
                continue
            seen_rows.add(r)

            # TODO put row in dict format indexed on colnames, to make more
            # robust

            label = r[0]
            field = self.column_field(r)
            if field is None:
                continue

            setattr(RowForm, label, field)

            # TODO maybe sort so all entries in static table come before all in
            # history table
            order_and_label.append((row[-1], label))

        # TODO put question mark at end of label for boolean fields?

        # TODO just compute all (non-default?) attributes in jinja?
        RowForm.fields = \
            [x[1] for x in sorted(order_and_label, key=lambda x: x[0])]

        if len(RowForm.fields) > 0:
            setattr(RowForm, 'add', SubmitField('Add'))
            RowForm.fields.append('add')

        # TODO best way to check for enum?
        # is enum the only thing i'm using that is USER-DEFINED in type
        # returned from information schema? and the only thing that i'll
        # ever likely use that will have that value?

        # TODO deal w/ array of pictures (in a way that works w/ other
        # arrays?) array of custom type or something?
        return RowForm(request_form)


    # TODO make this an attribute .pretty_name or something?
    # and use this for html? separate magic for that?
    def __str__(self):
        return pretty_name(self.name)


def list_tables():
    # One of the % symbols is to escape the other (since it has special meaning
    # in Python)
    tables = conn.execute("""
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema NOT IN ('pg_catalog', 'information_schema') AND
        table_schema NOT LIKE 'pg_toast%%' AND
        table_name NOT IN (SELECT table_name FROM flypush_tables
        WHERE website_visible IS NOT TRUE)
    """)
    return [Table(t[0]) for t in tables if '_history' not in t[0]]


def pretty_name(table_name):
    return table_name.capitalize().replace('_', ' ')


@app.route('/')
def index():
    tables = list_tables()
    return render_template('index.html',
        host=socket.gethostname(),
        tables=tables
    )


@app.route('/login', methods=['POST'])
def login():
    # TODO check user currently exists (and do i need to do something else to
    # save the user for use in other functions?)
    #if request.form['user']
    # TODO remove dropdown from html if no users?
    print(request.form['user'])


# TODO at least 'boxes' seems to be taking a while to load. fix some cause?
@app.route('/<table_name>', methods=['GET','POST'])
def render_table(table_name):
    tables = list_tables()

    table = None
    for t in tables:
        if t.name == table_name:
            table = t

    if table is None:
        # TODO how to add message to 404?
        abort(404)

    editable = conn.execute("""
    SELECT table_name
    FROM information_schema.tables
    WHERE table_name = '{}' AND
        table_schema NOT IN ('pg_catalog', 'information_schema') AND
        table_schema NOT LIKE 'pg_toast%%' AND
        table_name NOT IN (SELECT table_name FROM flypush_tables
        WHERE website_editable IS NOT TRUE)
    """.format(table_name))
    form = None
    if editable.rowcount > 0:
        form = table.add_row_form(request.form)

    # TODO maybe include messages saying what is responsible for adding data
    # (instructions for how to do so?) in cases where table isn't editable in
    # website

    # TODO does this also take care of error message on validation failure?
    # TODO TODO if dropdown on not null fk would be empty, display message
    # saying you need to add some of that item first (circular deps? prevented
    # at sql level?)
    if request.method == 'POST':
        if form.validate():
            print('form validated')
        else:
            print('form did not validate')

        # TODO way to get all data in form into some rep. of a row?
        # TODO call another function that adds row to table(s)

    df = table.to_df()
    # TODO TODO only render stuff owned by current user (default to showing

    # TODO modify html so that None (NULL in db) displays as a dash?
    return render_template('table.html', host=socket.gethostname(),
        tables=tables, table=df.to_html(), form=form)

# TODO make only new_user page show up if no users in db?
# TODO TODO make new user button redirect to people page, and focus form

# TODO checkbox to show historical data for things like boxes, and maybe
# otherwise only show most recent info?

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5555)
